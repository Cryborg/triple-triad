# Triple Triad v0.11 - Moteur de Jeu & API

## ğŸ“‹ Objectifs GÃ©nÃ©raux

- **Finaliser le dÃ©couplage** du moteur de jeu (GameEngine) de l'interface console
- **Standardiser la communication** de l'Ã©tat du jeu pour une intÃ©gration graphique facile
- **Exposer une API claire** pour interagir avec le moteur

## ğŸ¯ Composants ClÃ©s et AmÃ©liorations

### 1. DÃ©couplage Complet de l'EntrÃ©e/Sortie (I/O)

**ğŸ”Œ Suppression des Affichages Console Internes**
- Le moteur de jeu ne doit plus imprimer directement dans la console
- Les fonctionnalitÃ©s d'affichage actuelles (v0.7) doivent Ãªtre dÃ©placÃ©es vers un module d'interface utilisateur sÃ©parÃ© (`ConsoleUI.js`)

**âŒ¨ï¸ Gestion des EntrÃ©es**
- S'assurer que les actions des joueurs (placement de cartes, sÃ©lection de rÃ¨gles) sont traitÃ©es via des appels de fonctions standard
- Remplacer les lectures directes de la console par des paramÃ¨tres de mÃ©thodes

### 2. Raffinement du SystÃ¨me d'Ã‰vÃ©nements (Event System)

Le systÃ¨me d'Ã©vÃ©nements doit Ãªtre la principale source d'information sur les changements d'Ã©tat du jeu.

**ğŸ“¡ Couverture ComplÃ¨te des Ã‰vÃ©nements**
- S'assurer que chaque action significative et chaque changement d'Ã©tat dÃ©clenche un Ã©vÃ©nement prÃ©cis
- Ã‰vÃ©nements couverts : dÃ©marrage du jeu, fin de tour, changement de rÃ¨gles, captures multiples
- Fournir les donnÃ©es nÃ©cessaires avec chaque Ã©vÃ©nement

**ğŸ“Š Formatage des DonnÃ©es d'Ã‰vÃ©nement**
- Les donnÃ©es transmises par les Ã©vÃ©nements doivent Ãªtre claires et structurÃ©es (JSON)
- Suffisantes pour permettre Ã  une interface graphique de mettre Ã  jour son affichage
- Aucune requÃªte supplÃ©mentaire au moteur nÃ©cessaire

### 3. API du Moteur et SÃ©rialisation de l'Ã‰tat du Jeu

**ğŸ”— Interface Publique du Moteur (GameEngine API)**

DÃ©finir une API publique claire pour que l'interface graphique puisse interagir avec le moteur :

```javascript
// API principales
GameEngine.startGame(rulesConfig)
GameEngine.playCard(playerID, cardID, position)
GameEngine.getCurrentState()

// Gestion d'Ã©tat
GameEngine.serializeState()
GameEngine.restoreState(serializedData) // Facultatif
```

**ğŸ’¾ SÃ©rialisation de l'Ã‰tat**
- ImplÃ©menter une mÃ©thode `GameEngine.serializeState()` qui retourne l'Ã©tat complet du jeu
- Format JSON contenant : plateau, cartes, joueurs, rÃ¨gles actives, tour actuel
- Facile Ã  consommer par une interface graphique

**ğŸ”„ DÃ©sÃ©rialisation/Restauration** *(Facultatif mais recommandÃ©)*
- Ajouter une mÃ©thode `GameEngine.restoreState(serializedData)`
- Charger un Ã©tat de jeu depuis les donnÃ©es sauvegardÃ©es (prÃ©paration v0.10)

### 4. Tests et Documentation

**ğŸ§ª Tests de Non-RÃ©gression**
- VÃ©rifier que le dÃ©couplage I/O ne compromet pas le moteur de jeu existant
- S'assurer que l'IA (v0.10) continue de fonctionner correctement
- Maintenir la compatibilitÃ© avec tous les systÃ¨mes d'Ã©vÃ©nements

**ğŸ“š Documentation de l'API**
- Documenter clairement la nouvelle API du moteur de jeu avec JSDoc
- Faciliter le dÃ©veloppement de l'interface graphique en v0.12
- Fournir des exemples d'utilisation pour chaque mÃ©thode de l'API

## âœ… CritÃ¨res de RÃ©ussite

- [ ] DÃ©couplage complet I/O - aucun affichage console dans le moteur
- [ ] Module ConsoleUI.js sÃ©parÃ© pour l'interface console
- [ ] SystÃ¨me d'Ã©vÃ©nements complet et documentÃ©
- [ ] API GameEngine publique et fonctionnelle
- [ ] MÃ©thode serializeState() implÃ©mentÃ©e
- [ ] Tests de non-rÃ©gression passant Ã  100%
- [ ] Documentation JSDoc complÃ¨te de l'API
- [ ] Interface graphique peut consommer l'API sans modification du moteur

## ğŸ”— DÃ©pendances

- **v0.8** : Architecture consolidÃ©e nÃ©cessaire pour le dÃ©couplage
- **v0.7** : FonctionnalitÃ©s d'affichage Ã  migrer vers ConsoleUI
- **v0.10** : IA experte Ã  prÃ©server lors du dÃ©couplage

## ğŸ¯ PrÃ©paration pour v0.12

Cette version prÃ©pare l'infrastructure nÃ©cessaire pour l'interface graphique :
- API standardisÃ©e et documentÃ©e
- SystÃ¨me d'Ã©vÃ©nements robuste
- SÃ©rialisation d'Ã©tat pour l'intÃ©gration GUI
- Tests de compatibilitÃ© pour les futures interfaces